{
  "url": "https://api.github.com/repos/kemu3007/portal/issues/10",
  "repository_url": "https://api.github.com/repos/kemu3007/portal",
  "labels_url": "https://api.github.com/repos/kemu3007/portal/issues/10/labels{/name}",
  "comments_url": "https://api.github.com/repos/kemu3007/portal/issues/10/comments",
  "events_url": "https://api.github.com/repos/kemu3007/portal/issues/10/events",
  "html_url": "https://github.com/kemu3007/portal/issues/10",
  "id": 1160543378,
  "node_id": "I_kwDOG7qoq85FLHyS",
  "number": 10,
  "title": "Using Gmail API push notification",
  "user": {
    "login": "kemu3007",
    "id": 29157528,
    "node_id": "MDQ6VXNlcjI5MTU3NTI4",
    "avatar_url": "https://avatars.githubusercontent.com/u/29157528?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kemu3007",
    "html_url": "https://github.com/kemu3007",
    "followers_url": "https://api.github.com/users/kemu3007/followers",
    "following_url": "https://api.github.com/users/kemu3007/following{/other_user}",
    "gists_url": "https://api.github.com/users/kemu3007/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kemu3007/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kemu3007/subscriptions",
    "organizations_url": "https://api.github.com/users/kemu3007/orgs",
    "repos_url": "https://api.github.com/users/kemu3007/repos",
    "events_url": "https://api.github.com/users/kemu3007/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kemu3007/received_events",
    "type": "User",
    "site_admin": false
  },
  "labels": [
    {
      "id": 3898939400,
      "node_id": "LA_kwDOG7qoq87oZRgI",
      "url": "https://api.github.com/repos/kemu3007/portal/labels/article",
      "name": "article",
      "color": "C200E5",
      "default": false,
      "description": ""
    },
    {
      "id": 3900073969,
      "node_id": "LA_kwDOG7qoq87odmfx",
      "url": "https://api.github.com/repos/kemu3007/portal/labels/GCP",
      "name": "GCP",
      "color": "FBCA04",
      "default": false,
      "description": ""
    }
  ],
  "state": "open",
  "locked": false,
  "assignee": null,
  "assignees": [],
  "milestone": null,
  "comments": 0,
  "created_at": "2022-03-06T07:47:32Z",
  "updated_at": "2022-03-06T15:19:57Z",
  "closed_at": null,
  "author_association": "OWNER",
  "active_lock_reason": null,
  "body": "You will be able to hook into the email and interject the process.\n\n### Environment\n-  Python 3.10\n-  google- api- python- client==2.36.0\n-  google_auth_oauthlib=0.4.6\n-  google- cloud- pubsub==2.9.0\n\n\n### Procedure\n① Create a project from GCP console and activate [Gmail API](https://console.cloud.google.com/apis/api/gmail.googleapis.com/)\n\nClick Gmail API - > Authentication Info - > Create Authentication Info and create an OAuth client ID (if you are just playing around at hand, it is convenient to select the desktop app as you do not have to think about the redirect URI).\n\n(3) After creating OAuth client ID, click to access and download JSON\n\n4) Since the JSON you downloaded does not have a token, execute the following code, click on the URL displayed in the console to consent, paste the generated code into the console, and save the authentication information in the form of a pickle. (The description is based on djnago, but there is no need to be aware of it.)\n\n- - - \n\n```py\nimport json\nimport pickle\nfrom pathlib import Path\n\nfrom django.conf import settings\nfrom django.core.management.base import BaseCommand\nfrom google_auth_oauthlib.flow import InstalledAppFlow\n\n\nclass Command(BaseCommand):\n    def handle(self, *args, **options):\n        credential_path: Path = settings.BASE_DIR.parent / \"auth.json\"\n        credential_scopes = [\"https://mail.google.com/\"]\n        raw_credentials = json.loads(credential_path.read_text())\n        flow = InstalledAppFlow.from_client_config(raw_credentials, credential_scopes)\n        credentials = flow.run_console()\n        with open(\"token.pickle\", \"wb\") as token:\n            pickle.dump(credentials, token)\n```\n\n- - - \n\n5) Create [pub/sub](https://console.cloud.google.com/cloudpubsub/) which is required for Gmail push notification from GCP console. (6) Create a topic first. You do not need to check any checkboxes at this time.\n\n(6) Set the PUBLISHER for the topic. Click `Add Principal` in the Permissions column of the Information Panel on the right side of the screen and add `gmail- api- push@system.gserviceaccount.com` as the role `Pub/Sub Publisher`.\n\n(g) Create a subscription. Select `pull` for the delivery type. The topic will be the one you created in step 5.\n\n⑧ Execute `users.watch` based on the authentication information created in step 4. In this case, by specifying labelIds as INBOX, the notification controls the event firing.\n\n- - - \n\n```py\nfrom googleapiclient.discovery import build\n\nwith open(settings.BASE_DIR / \"mail/token.pickle\", \"rb\") as token:\n    credentials = pickle.load(token)\nservice = build(\"gmail\", \"v1\", credentials=self.credentials)\n# settings.PUBSUB_TOPICには  projects/{project_name}-{project_id}/topics/{topic_name} のような値が入ります。\nservice.users().watch(userId=\"me\", body={\"labelIds\": [\"INBOX\"], \"topicName\": settings.PUBSUB_TOPIC}).execute()\n```\n\n- - - \n\n(9) Set callback function and subscribe\n\n- - - \n\n```py\nfrom google.cloud.pubsub_v1 import SubscriberClient\n\n# settings.PUBSUB_SUBSCRIPTIONにはprojects/{project_name}-{project_id}/subscriptions/{topic_name} のような値が入ります\nSubscriberClient(credentials=credentials).subscribe(settings.PUBSUB_SUBSCRIPTION, callback=callback)\n```\n\n- - - \n\n⑩ The data obtained by subscribe is in the following format.\nhttps://developers.google.com/gmail/api/guides/push#receiving_notifications\n\nNote that the \"messageId\" in this case has nothing to do with the gmail ID.\n\n(11) Obtain messages based on historyId\n\nIf you use the historyId obtained in step 10, you may not be able to get it due to the convenience of using the startHistoryId query. Therefore, it is necessary to use the previous value or, if it does not exist, the historyId from when `user.watch` was used.\n\n- - - \n\n```py\nhistories = service.users().history().list(userId=\"me\", historyTypes=[\"messageAdded\"], labelId=\"INBOX\", startHistoryId=past_history_id).execute(num_retries=5)\nmessage_id = histories[\"history\"][0][\"messagesAdded\"][0][\"message\"][\"id\"]\nmessage = self.service.users().messages().get(userId=\"me\", id=message_id).execute(num_retries=5)\n```\n\n- - - \n\n⑫ Since the message was obtained in step 12, notify slack, save to DB, or do any other process you like.\n\nSince the body text is encoded in base64, please handle it by `base64.urlsafe_b64decode`.\n\n### Attention.\n\n-  Please do not upload your credentials to github, etc., as you are dealing with GCP access rights.\n-  `user.watch` needs to be run periodically. I think it would be a good idea to make it a command and apply periodic execution by oferia, cron, etc.\n\n### General Comments\n\nAlthough there are many easier ways to send emails to slack, I thought it would be useful if you want to interject other processes or store email information in an easy- to- use DB.\n\nWe had a hard time because there were few Japanese- language materials lying around, but we managed to get it up to a working slackbot in one day, so I'm happy about that.",
  "reactions": {
    "url": "https://api.github.com/repos/kemu3007/portal/issues/10/reactions",
    "total_count": 0,
    "+1": 0,
    "-1": 0,
    "laugh": 0,
    "hooray": 0,
    "confused": 0,
    "heart": 0,
    "rocket": 0,
    "eyes": 0
  },
  "timeline_url": "https://api.github.com/repos/kemu3007/portal/issues/10/timeline",
  "performed_via_github_app": null,
  "state_reason": null
}
