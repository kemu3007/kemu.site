{"url": "https://api.github.com/repos/kemu3007/portal/issues/45", "repository_url": "https://api.github.com/repos/kemu3007/portal", "labels_url": "https://api.github.com/repos/kemu3007/portal/issues/45/labels{/name}", "comments_url": "https://api.github.com/repos/kemu3007/portal/issues/45/comments", "events_url": "https://api.github.com/repos/kemu3007/portal/issues/45/events", "html_url": "https://github.com/kemu3007/portal/issues/45", "id": 1239705698, "node_id": "I_kwDOG7qoq85J5Ghi", "number": 45, "title": "尝试Django 4.1异步视图，异步ORM", "user": {"login": "kemu3007", "id": 29157528, "node_id": "MDQ6VXNlcjI5MTU3NTI4", "avatar_url": "https://avatars.githubusercontent.com/u/29157528?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kemu3007", "html_url": "https://github.com/kemu3007", "followers_url": "https://api.github.com/users/kemu3007/followers", "following_url": "https://api.github.com/users/kemu3007/following{/other_user}", "gists_url": "https://api.github.com/users/kemu3007/gists{/gist_id}", "starred_url": "https://api.github.com/users/kemu3007/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kemu3007/subscriptions", "organizations_url": "https://api.github.com/users/kemu3007/orgs", "repos_url": "https://api.github.com/users/kemu3007/repos", "events_url": "https://api.github.com/users/kemu3007/events{/privacy}", "received_events_url": "https://api.github.com/users/kemu3007/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 3898939400, "node_id": "LA_kwDOG7qoq87oZRgI", "url": "https://api.github.com/repos/kemu3007/portal/labels/article", "name": "article", "color": "C200E5", "default": false, "description": ""}, {"id": 3900075763, "node_id": "LA_kwDOG7qoq87odm7z", "url": "https://api.github.com/repos/kemu3007/portal/labels/Django", "name": "Django", "color": "5FC353", "default": false, "description": ""}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-05-18T09:48:28Z", "updated_at": "2022-05-18T13:36:03Z", "closed_at": null, "author_association": "OWNER", "active_lock_reason": null, "body": "自Django4.1alpha1发布以来，我们确认了新功能和操作。\r\n\r\n[django 4.1 alpha 1版本]\r\n[django 4.1发行注]（https://docs.djangoproject.com/en/dev/releases/4.1/）\r\n\r\nDjango4.1中注明了以下两个点。\r\n\r\n - 基于班级视图的同步处理程序\r\n-Asynchronous ORM接口\r\n\r\n\r\n＃＃ 介绍\r\n````bash\r\n$ pip安装“ django == 4.1a1”\r\n````````\r\n\r\n##确认依赖性\r\n依赖性与django3.2时没有什么不同。 （Pytz消失了）\r\n``````文字\r\nasgiref == 3.5.2\r\ndjango == 4.1A1\r\nsqlparse == 0.4.2\r\n````````\r\n\r\n\r\n##基于班级视图的异步处理程序\r\n一秒钟后返回响应的观点，尤其是因为使用Asyncio是正式的，但这是正式的。\r\n\r\n``python\r\n导入异步\r\n来自django.http导入httpresponse\r\n从django.Views导入视图\r\n\r\n\r\n类asyncview（查看）：\r\n    异步def获取（自我，请求， *args，** kwargs）：\r\n        “”“”等待1秒后返回响应\r\n        等待asyncio.sleep（1）\r\n        返回httpresponse（“ Hello World”）\r\n````````\r\n\r\n##异步ORM接口\r\n - 如果您查看`django/db/models/query.py'，则存在以下新功能。\r\n - 如果您查看实现，则使用Asgiref的`asgiref/sync/sync/sync_to_async`将同步函数用作同步函数。\r\n\r\n``````文字\r\nAiterator\r\n融合\r\nacount\r\nAget\r\n饱粉\r\nabulk_create\r\nabulk_update\r\naget_or_create\r\naupdate_or_create\r\nAearlist\r\nalatest\r\n首先\r\n阿拉斯特\r\nain_bulk\r\nAdelete\r\naupdate\r\nAEXISTS\r\na后\r\nAxplain\r\n````````\r\n\r\n##确认异步操作\r\n如果执行正常的同步处理，则将通过以下过程进行处理。\r\n\r\n将查询a to db->返回查询A的结果 - \r\n\r\n如果实现异步操作，则可以预期以下操作。\r\n\r\n将查询a to db->扔查询b to db->查询a的结果返回 - >查询b的结果返回\r\n\r\n\r\n````py\r\n导入异步\r\n导入时间\r\n\r\n来自django.contrib.auth.models导入用户\r\n来自django.contrib.sessions.models导入会话\r\n来自django.http导入httpresponse\r\n从django.Views导入视图\r\n来自Model_Bakery Import Baker\r\n\r\ndef bulk_create（过程：str，模型，实例）：\r\n    start = time.time（）\r\n    打印（f“ sync start_create {process}”）\r\n    model.objects.bulk_create（实例）\r\n    print（f“ sync end_agg {process} {time.time（） -  start}”）\r\n\r\n\r\n类SyncgetView（View）：\r\n    def获取（自我，请求， *args，** kwargs）：\r\n        用户= baker.prepare（用户，_Quantity = 3000）\r\n        会话=贝克。\r\n        start = time.time（）\r\n        bulk_create（“用户”，用户，用户）\r\n        bulk_create（“会话”，会话，会话）\r\n        end = time.time（）\r\n        返回httpresponse（f“ {end -start}”）\r\n\r\n\r\n异步def abulk_create（过程：str，模型，实例）：\r\n    start = time.time（）\r\n    打印（f“ async start_create {process}”）\r\n    等待型号。\r\n    print（f“ async end_agg {process} {time.time（）-tart}”）\r\n\r\n\r\n类asyncgetView（view）：\r\n    异步def获取（自我，请求， *args，** kwargs）：\r\n        用户= baker.prepare（用户，_Quantity = 3000）\r\n        会话=贝克。\r\n        start = time.time（）\r\n        等待asyncio.gather（abulk_create（“用户”，用户，用户），abulk_create（“ session”，session，sessions）\r\n        end = time.time（）\r\n        返回httpresponse（f“ {end -start}”）\r\n````````\r\n使用此代码，测量称为“ burk_create”或“ abulk_create”的时间。\r\n\r\n###输出结果\r\n\r\n####同步处理\r\n``````文字\r\ndjango_4_1_sample-web-1 |同步start_create用户\r\ndjango_4_1_sample-web-1 | sync end_create用户1.0495100021362305\r\ndjango_4_1_sample-web-1 |同步start_create会话\r\ndjango_4_1_sample-web-1 | sync end_create会话0.227380514489746\r\n````````\r\n\r\n####异步处理\r\n``````文字\r\ndjango_4_1_sample-web-1 | async start_create用户\r\ndjango_4_1_sample-web-1 | async start_create会话\r\ndjango_4_1_sample-web-1 | async end_create用户0.82750129697033\r\ndjango_4_1_sample-web-1 | async end_create会话1.0836100578308105\r\n````````\r\n\r\n可以看出，正在从“ start_create”的时间安排中执行异步处理。\r\n\r\n尽管计算时间是测量的，但在此时间使用的model_bakery中制备的实例是随机的，并且记录的数量是不同的，因为记录的数量有所不同，因为DB没有分离。我忽略了它，因为没有。\r\n\r\n\r\n##代码这段时间\r\n\r\n[django_4_1_sample]（https://github.com/kemu3007/django_4_1_sample）", "reactions": {"url": "https://api.github.com/repos/kemu3007/portal/issues/45/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/kemu3007/portal/issues/45/timeline", "performed_via_github_app": null, "state_reason": null}