{"url": "https://api.github.com/repos/kemu3007/portal/issues/45", "repository_url": "https://api.github.com/repos/kemu3007/portal", "labels_url": "https://api.github.com/repos/kemu3007/portal/issues/45/labels{/name}", "comments_url": "https://api.github.com/repos/kemu3007/portal/issues/45/comments", "events_url": "https://api.github.com/repos/kemu3007/portal/issues/45/events", "html_url": "https://github.com/kemu3007/portal/issues/45", "id": 1239705698, "node_id": "I_kwDOG7qoq85J5Ghi", "number": 45, "title": "Try django 4.1 Async View, Async ORM", "user": {"login": "kemu3007", "id": 29157528, "node_id": "MDQ6VXNlcjI5MTU3NTI4", "avatar_url": "https://avatars.githubusercontent.com/u/29157528?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kemu3007", "html_url": "https://github.com/kemu3007", "followers_url": "https://api.github.com/users/kemu3007/followers", "following_url": "https://api.github.com/users/kemu3007/following{/other_user}", "gists_url": "https://api.github.com/users/kemu3007/gists{/gist_id}", "starred_url": "https://api.github.com/users/kemu3007/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kemu3007/subscriptions", "organizations_url": "https://api.github.com/users/kemu3007/orgs", "repos_url": "https://api.github.com/users/kemu3007/repos", "events_url": "https://api.github.com/users/kemu3007/events{/privacy}", "received_events_url": "https://api.github.com/users/kemu3007/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 3898939400, "node_id": "LA_kwDOG7qoq87oZRgI", "url": "https://api.github.com/repos/kemu3007/portal/labels/article", "name": "article", "color": "C200E5", "default": false, "description": ""}, {"id": 3900075763, "node_id": "LA_kwDOG7qoq87odm7z", "url": "https://api.github.com/repos/kemu3007/portal/labels/Django", "name": "Django", "color": "5FC353", "default": false, "description": ""}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2022-05-18T09:48:28Z", "updated_at": "2022-05-18T13:36:03Z", "closed_at": null, "author_association": "OWNER", "active_lock_reason": null, "body": "Since Django4.1alpha1 was released, we confirmed the new functions and operation.\r\n\r\n[Django 4.1 Alpha 1 Release]\r\n[Django 4.1 Release Note] (https://docs.djangoproject.com/en/dev/releases/4.1/)\r\n\r\nThe following two points are noted in Django4.1.\r\n\r\n-Asynchronous Handlers for Class-Based Views\r\n-Asynchronous ORM Interface\r\n\r\n\r\n## Introduction\r\n`` `bash\r\n$ Pip Install \"Django == 4.1a1\"\r\n`` `\r\n\r\n## Confirmation of dependency\r\nThe dependence is not different from when Django3.2. (The pytz disappeared)\r\n`` `TEXT\r\nASGIREF == 3.5.2\r\nDjango == 4.1a1\r\nsqlparse == 0.4.2\r\n`` `\r\n\r\n\r\n## Asynchronous Handlers for Class-Based Views\r\nA view that returns the response after one second, especially because it is official to use asyncio, but it was official.\r\n\r\n`` `python\r\nImport asyncio\r\nFrom Django.http Import IMPORT HTTPRESPONSE\r\nFrom Django.Views IMPORT VIEW\r\n\r\n\r\nClass AsyncView (View):\r\n    Async Def Get (Self, Request, *Args, ** kwargs):\r\n        \"\" \"\" \"\" Return the response after waiting for 1 second \"\r\n        await asyncio.sleep (1)\r\n        Return httpresponse (\"Hello World\")\r\n`` `\r\n\r\n## asynchronous ORM Interface\r\n-If you look at `django/db/models/query.py`, the following new functions exist.\r\n-If you look at the implementation, the synchronization function is used as a synchronous function using ASGIREF's `asgiref/sync/sync_to_async`.\r\n\r\n`` `TEXT\r\nAITERATOR\r\nAAGGREGATE\r\nAcount\r\naget\r\nACREATE\r\nABULK_CREATE\r\nABULK_UPDATE\r\naget_or_create\r\nAUPDATE_OR_CREATE\r\naearlist\r\nalatest\r\nafirst\r\nalast\r\nain_bulk\r\nadelete\r\nAUPDATE\r\naexists\r\nAcontains\r\naexplain\r\n`` `\r\n\r\n## Confirmation of asynchronous operation\r\nIf normal synchronization processing is performed, the processing will proceed by the following procedure.\r\n\r\nThrow Query A to DB-> The result of query A is returned-> Throw the query B to the DB-> The result of the query B is returned\r\n\r\nIf asynchronous operation is realized, the following operation is expected.\r\n\r\nThrow Query A to DB-> Throw Query B to DB-> The result of query A is returned-> The result of the query B is returned\r\n\r\n\r\n`` `py\r\nImport asyncio\r\nImport Time\r\n\r\nFrom django.contrib.auth.models IMPORT User\r\nFrom django.contrib.sessions.models Import Session\r\nFrom Django.http Import IMPORT HTTPRESPONSE\r\nFrom Django.Views IMPORT VIEW\r\nFrom Model_bakery Import Baker\r\n\r\nDef Bulk_create (Process: Str, Model, Instance):\r\n    Start = Time.Time ()\r\n    Print (F \"Sync Start_create {Process}\")\r\n    Model.objects.bulk_create (Instance)\r\n    Print (f \"sync end_agg {Process} {Time.Time () -Start}\")\r\n\r\n\r\nClass SyncgetView (View):\r\n    DEF GET (Self, Request, *Args, ** kwargs):\r\n        Users = baker.prepare (user, _quantity = 3000)\r\n        sessions = baker.prepare (session, _quantity = 3000)\r\n        Start = Time.Time ()\r\n        Bulk_create (\"user\", user, users)\r\n        Bulk_create (\"session\", session, sessions)\r\n        END = Time.Time ()\r\n        Return httpresponse (f \"{End -Start}\")\r\n\r\n\r\nAsync Def ABULK_CREATE (Process: Str, Model, Instance):\r\n    Start = Time.Time ()\r\n    Print (f \"async Start_create {Process}\")\r\n    AWAIT Model.objects.abulk_create (Instance)\r\n    Print (f \"async end_agg {Process} {Time.Time () -Tart}\")\r\n\r\n\r\nClass asyncgetView (view):\r\n    Async Def Get (Self, Request, *Args, ** kwargs):\r\n        Users = baker.prepare (user, _quantity = 3000)\r\n        sessions = baker.prepare (session, _quantity = 3000)\r\n        Start = Time.Time ()\r\n        await asyncio.gather (abULK_CREATE (\"user\", user, users), ABULK_CREATE (\"Session\", Session, Sessions)\r\n        END = Time.Time ()\r\n        Return httpresponse (f \"{End -Start}\")\r\n`` `\r\nWith this code, measure the time when `burk_create` or` abULK_CREATE` is called.\r\n\r\n### Output result\r\n\r\n#### Synchronous processing\r\n`` `TEXT\r\ndjango_4_1_sample-web-1 | Sync Start_create User\r\ndjango_4_1_sample-web-1 | Sync End_create User 1.0495100021362305\r\ndjango_4_1_sample-web-1 | Sync START_CREATE SESSION\r\ndjango_4_1_sample-web-1 | Sync End_create Session 0.227380514489746\r\n`` `\r\n\r\n#### asynchronous processing\r\n`` `TEXT\r\ndjango_4_1_sample-web-1 | async start_create user\r\ndjango_4_1_sample-web-1 | async start_create session\r\ndjango_4_1_sample-web-1 | async END_CREATE user 0.827501296970703\r\ndjango_4_1_sample-web-1 | async END_CREATE SESSION 1.0836100578308105\r\n`` `\r\n\r\nIt can be seen that asynchronous processing is being performed from the timing of `Start_create`.\r\n\r\nAlthough the calculation time was measured, the instance prepared in the model_bakery used this time was randomized, and the number of records was different because the number of records was different because the DB was not separated. I ignore it because there is no.\r\n\r\n\r\n## Code used this time\r\n\r\n[django_4_1_sample] (https://github.com/kemu3007/django_4_1_sample)", "reactions": {"url": "https://api.github.com/repos/kemu3007/portal/issues/45/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0, "rocket": 0, "eyes": 0}, "timeline_url": "https://api.github.com/repos/kemu3007/portal/issues/45/timeline", "performed_via_github_app": null, "state_reason": null}